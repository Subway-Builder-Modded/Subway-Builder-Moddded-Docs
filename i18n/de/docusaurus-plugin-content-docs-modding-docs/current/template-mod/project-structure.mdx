---
id: project-structure
title: Projektstruktur
---

Hier steht was jede Datei der Vorlage macht.

```
├── src/
│   ├── main.ts                # Einstiegspunkt deiner Mod
│   ├── ui/
│   │   └── ExamplePanel.tsx   # React Beispielkomponente
│   └── types/
│       ├── react.ts           # React-Shim (lädt React aus der Spiel-API)
│       ├── index.d.ts         # Re-Export + globale Window-Deklarationen
│       ├── api.d.ts           # Hauptschnittstelle der Modding-API
│       ├── core.d.ts          # Koordinaten, BoundingBox, Spielgeschwindigkeit
│       ├── game-state.d.ts    # Typen für Station, Strecke, Zug, Route
│       ├── game-constants.d.ts# Spielkonstanten, Baukosten
│       ├── game-actions.d.ts  # Typen für Anleihe (Bond) und Anleihetyp
│       ├── build.d.ts         # Typen für Bau-/Build-Automatisierung
│       ├── ui.d.ts            # UI-Positionierungen & Optionstypen
│       ├── cities.d.ts        # Typen für Stadt und Stadtkonfiguration
│       ├── trains.d.ts        # Zugtyp-Konfiguration und -Statistiken
│       ├── stations.d.ts      # Bahnhofstyp-Konfiguration
│       ├── map.d.ts           # Kartenquellen, Ebenen und Überschreibungen
│       ├── career.d.ts        # Missionskonfiguration, StarConfig
│       ├── content-templates.d.ts # Vorlagen für Zeitung und Tweets
│       ├── pop-timing.d.ts    # Pendelzeitbereich
│       ├── i18n.d.ts          # I18n-API
│       ├── utils.d.ts         # Recharts-Komponenten
│       ├── schemas.d.ts       # Zod-Validierungsschemata
│       ├── electron.d.ts      # Electron-API-Typen
│       └── manifest.d.ts      # ModManifest-Typ
├── scripts/
│   ├── run.ts                 # Spielstarter mit Logging
│   └── link.ts                # Verwaltung von Symlinks
├── manifest.json              # Mod-Metadaten (werden vom Spiel geladen)
├── vite.config.ts             # Build-Konfiguration
├── tsconfig.json              # TypeScript-Konfiguration
└── package.json               # Abhängigkeiten und Skripte
```

## Wichtige Dateien {#key-files}

### `manifest.json` {#manifest.json}

Das Spiel nutzt diese Datei zur Identifikation der Mod. Erforderliche Felder:

```json
{
  "id": "com.deinname.deinemod",
  "name": "Meine tolle Mod",
  "description": "Macht was cooles",
  "version": "1.0.0",
  "author": { "name": "Dein Name" },
  "main": "index.js"
}
```

- `id` — Einzigartiger reverse-domain-Identifikator
- `main` — immer `"index.js"` (der Vite Build Output)

### `src/main.ts` {#main.ts}

Einstiegspunkt deiner Mod. Hier registrierst du Hooks, fügst UI-Elemente hinzu und erstellst die 
Logik deiner Mod. Die Vorlage enthält ein funktionierendes Beispiel:

```ts
const api = window.SubwayBuilderAPI;

if (!api) {
  console.error('SubwayBuilderAPI not found!');
} else {
  let initialized = false;

  api.hooks.onMapReady((_map) => {
    if (initialized) return;
    initialized = true;

    // Setup deiner Mod hier
    api.ui.addFloatingPanel({
      id: 'my-mod-panel',
      title: 'My Mod',
      icon: 'Puzzle',
      render: ExamplePanel,
    });
  });
}
```

### `src/ui/ExamplePanel.tsx` {#examplepanel.tsx}

Eine einfache React-Komponente um die Verwendung von Spiel-UI-Elementen und Hooks in einem fliegenden Fenster 
zu demonstrieren:

```tsx
import { useState } from 'react';

const api = window.SubwayBuilderAPI;
const { Button } = api.utils.components as Record<string, React.ComponentType<any>>;

export function ExamplePanel() {
  const [count, setCount] = useState(0);

  return (
    <div className="flex flex-col gap-3 p-3">
      <p className="text-sm text-muted-foreground">Click count: {count}</p>
      <Button onClick={() => setCount((c) => c + 1)}>Increment</Button>
    </div>
  );
}
```

### `src/types/react.ts` {#react.ts}

Der React-Shim. So funktioniert JSX in Mods. Anstelle React einzubinden, benutzt Shim React aus
der API des Spiels während der Laufzeit:

```ts
const React = window.SubwayBuilderAPI.utils.React;

export default React;
export const { useState, useEffect, useCallback, useMemo, useRef /* ... */ } = React;

// JSX Laufzeit Exporte
export const jsx = React.createElement;
export const jsxs = React.createElement;
```

Vite ist konfiguriert um `react` und `react/jsx-runtime` Importe auf diese Datei zu verlinken, so
kannst du einfach `import { useState } from 'react'` und es funktioniert.

### `vite.config.ts` {#vite.config.ts}

Die Build-Konfiguration. Wichtige Punkte:

- **Output format**: IIFE (immediately-invoked function expression) — das Spiel erwartet ein 
einzelnes Skript, keine ES-Module.
- **React aliasing**: Routet `react` Importe durch den Shim
- **Static copy**: Kopiert `manifest.json` nach `dist/` zusammen mit dem kompilierten JS
- **No minification**: Erzeugt lesbaren Output für Debugging

### `tsconfig.json` {#tsconfig.json}

Standard TypeScript Konfiguration mit:

- `strict: true` — Vollständige Type-Safety 
- `jsx: "react-jsx"` — Automatische JSX-Transformation
- `noEmit: true` — TypeScript wird nur für Type-Checking benutzt, Vite kümmert sich um das eigentliche Kompilieren

### `scripts/link.ts` {#link.ts}

Erstellt Symlink von `dist/` in den Mod-Ordner des Spiels. Greift auf die Mod-ID aus `manifest.json`
zu und nutzt das letzte Segment für den Ordnername (z.B. `com.autor.meinemod` wird `meinemod/`).

### `scripts/run.ts` {#run.ts}

Findet die Subway Builder Spieledatei auf deinem System und startet sie mit `ELECTRON_ENABLE_LOGGING=1`.
Schreibt stdout/stderr in `debug/latest.log` damit du den Output nach der Session überprüfen kannst.
