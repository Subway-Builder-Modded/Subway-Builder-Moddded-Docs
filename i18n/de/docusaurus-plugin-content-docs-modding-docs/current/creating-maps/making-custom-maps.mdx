---
id: making-custom-maps
title: Benutzerdefinierte Karten erstellen
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Dieser Leitfaden erklärt Dir, wie du eigene Karten für [Kronifer's Map Manager](https://github.com/Subway-Builder-Modded/subwaybuilder-patcher/releases) erstellen kannst. Wir werden mit [rslurry's Demand Data Generator](https://github.com/rslurry/subwaybuilder-US-demand-data) realistische Nachfragedaten generieren und dann unser Verzeichnis korrekt für den Map Manager formatieren und vorbereiten.

:::danger Vorsicht
Der Nachfragedaten-Generator funktioniert **ausschließlich** für Städte in den USA. Wenn du eine Stadt außerhalb der USA erstellen möchtest, musst du eine andere Möglichkeit finden, die erforderlichen Daten zu generieren und so zu formatieren, dass sie mit Subway Builder funktionieren. Da es sich dabei um ein komplexes Vorhaben handelt, dass sich von Land zu Land unterscheidet, wird es nicht in diesem Wiki behandelt. Grund dafür ist, dass nicht immer die erforderlichen Daten für jedes Land verfügbar sind.
:::

:::info Vorraussetzungen
Bevor du loslegst solltest du Dich mit ein paar Dingen vertraut machen. Wir werden diese Tools und Ressourcen im Verlauf des Leitfadens einsetzen.
 - [Git](https://git.org)
 - [node.js](https://https://nodejs.org)
 - Kenntnisse über das Terminal deines Betriebssystems
 - Verständnis von [JavaScript und JavaScript Syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
 - **Für Windows:** [WSL](https://learn.microsoft.com/en-us/windows/wsl/install)
:::

## Schritt 1 - Den Map Manager installieren {#installing-the-map-pacher}

Die alte Version von Kronifier's Map Manager enthielt eine grafische Oberfläche für den Map Patcher, die uns beim generieren unserer Daten helfen kann. Führe den folgenen Befehl aus, um den Map Patcher zu klonen:

```bash
git clone -b legacy https://github.com/Subway-Builder-Modded/subwaybuilder-patcher
```

Jetzt haben wir eine Kopie des klassischen Map Patchers installiert. Suche jetzt nach dem Installierscript und führe es aus. Auf Windows heißt das Script `Install dependencies.bat`. Auf MacOS und Linux heißt es `Install dependencies.sh`.  

## Schritt 2 - Daten generieren {#generating-data}

Starte das GUI (die grafische Benutzeroberfläche). Auf Windows führst du dafür `Start_GUI.bat` aus. Auf MacOS und Linux ist es `Start_GUI.sh`. Sobald es läuft, erscheint das GUI in deinem Browser. Es beinhaltet alles was wir zur Ausführung des Map Patchers benötigen.

<img width="1000" alt="image" src="/images/legacy-patcher.png" />

Wenn du den Patcher öffnest wirst du dazu aufgefordert, den Installationspfad von Subway Builder auf deinem System anzugeben. Es ist egal was du hier einfügst, da wir nicht wirklich das Spiel patchen werden. Auf dem nächsten Bildschirm stelle sicher, dass "`Map Patcher (Kronifer)`" ausgewählt ist. Sonst sollte nichts ausgewählt sein.

Sobald du dich in der Konfiguration des Map Patchers befindest, klicke auf den Tab "`Manual Configuration`". Hier werden wir die Felder zum Generieren unserer Daten ausfüllen.

::::tip
 - "Code": Der zwei bis vier Zeichen lange Städtecode für deine Karte. Es wird dringend empfohlen IATA oder ICAO Codes zu benutzen, es können jedoch auch andere Codes benutzt werden, solange sie nicht mit den IATA oder ICAO Codes anderer Städte in Konflikt geraten.

:::danger
Wenn der Code deiner Stadt mit dem Code einer bereits im Spiel enthaltenen Stadt in Konflikt gerät, kann deine Karte im Map Manager nicht geladen werden. du kannst eine Liste existierender Städtecodes in `metro-maker4/cities/latest-cities.yml` einsehen.
:::
 - "Name": Der Name deiner Stadt. Er wird im Map Manager und ingame beim Laden der Karte angezeigt.
 - "Description": Eine kurze Beschreibung deiner Stadt. Wird im Spiel angezeigt.
 - "Population": Die Bevölkerungszahl deiner Stadt.
:::note
Wenn du Google benutzt stelle sicher, dass die Bevölkerungszahl nur die arbeitenden Menschen erfasst, nicht die komplette Einwohnerzahl.
:::
 - "BBox": Die Koordinaten des Begrenzungsrahmens für deine Stadt. Er sollte im Format `[minLat /*Ost*/, minLon /*Süd*/, maxLat /*West*/, maxLon /*Nord*/]` vorliegen.
 - "Initial View State": Den ersten Bildausschnitt den alle Spieler beim ersten öffnen der Karte sehen. Für `zoom` und `bearing` werden die Standardwerte einwandfrei funktionieren.
::::

<img width="1000" alt="image" src="/images/map-patcher-config.png" />

Sobald du diese Daten eingegeben hast klicke auf "Next" und dann auf "Back". **Auf dem vorhergehenden Bildschirm klickst du einfach auf "`Run Full Map Setup`", ohne diesen Schritt wird deine Konfiguration nicht gespeichert und du würdest Daten für eine andere Karte generieren.**

Danach kannst du auf "`Run Full Map Setup`" klicken. Dadurch werden die Daten für deine Karte generiert. Sobald die Generierung abgeschlossen ist, findest du das Ergebnis unter `subwaybuilder-patcher/patcher/packages/mapPatcher/processed_data`. Wir benutzen `buildings_index.json`, `roads.geojson` und `runways_taxiways.geojson`. Du kannst  `demand_data.json` ignorieren, weil wir unsere Nachfragedaten im nächsten Schritt selber generieren. In `subwaybuilder-patcher/patcher/packages/mapPatcher/map_tiles` findest du außerdem eine `XXX.pmtiles` Datei, wobei `XXX` dein Städtecode ist. Diese Datei werden wir später noch brauchen. Du kannst den Patcher jetzt schließen.

:::danger Vorsicht
Durchlaufe nicht den Rest des Patcher Setups. Dies ist ein veralteter Patcher, dessen Funktion zum Modifizieren des Spiels nicht mehr unterstützt wird. Wir haben nur dieses GUI zum einfachen generieren unserer Daten genutzt.
:::

## Schritt 3 - Nachfragedaten generieren {#generating-demand-data}

<Tabs>
<TabItem value="windows" label="Windows" default>

:::important
Von hier an wird alles im Terminal via WSL ausgeführt. Der Demand Data Generator unterstützt windows **nicht**, deshalb müssen wir WSL einsetzen um die Linuxversion benutzen zu können. Alle Downloads von hier an sollten, soweit nicht anders angegeben, die Linuxversion sein.
:::

Öffne https://github.com/rslurry/subwaybuilder-US-demand-data/releases und lade den neuesten Release entsprechend deines Betriebssystems herunter. Erstelle ein temporäres Arbeitsverzeichnis für unsere Dateien und speichere den Release darin. Führe den folgenden Befehl aus(ersetze `<DEINE_BINÄR_DATEI>` mit dem Namen deiner Binärdatei, wo nötig):
```bash
chmod +x <DEINE_BINÄR_DATEI>.bin
```

Jetzt ist es Zeit, unsere Konfiguration zu erstellen. Erstelle eine Datei namens `<DEINE_STADT>.json`, wobei DEINE_STADT den Namen deiner Stadt meint (der Dateiname ist egal, aber das wird es später einfacher machen). Manche Parameter sind optional, einschließlich Flughafenbezogener Orte und Bevölkerungszahlen, Parameter für Universitäten und alle entertainmentbasierten Parameter.

In diese Datei fügst du folgende Parameter ein:
```json
    city : string, deine Stadt.  
              Beispiel: "Rochester"
    airport : Liste von strings, IATA Codes für lokale Flughäfen
                               Beachte: Der zuerst aufgeführte Flughafen wird hier benutzt um die Stadt eindeutig zuzuweisen.
              Beispiel: ["ROC"]
    states : string oder Liste von strings, zwei-Buchstaben Code für den Bundesstaat deiner Karte.
              Beispiel: "ny"
              Beispiel: ["md", "dc", "va"]
    year : int, das Jahr welches du für die LODES Daten benutzen möchtest. Zum Zeitpunkt des Schreibens muss es zwischen 2002-2023 liegen.  
              Beispiel: 2022
    bbox : Liste von ints, die [min_lon, min_lat, max_lon, max_lat] Begrenzungen für deine Stadt.  
              Beispiel: [-77.8216, 43.0089, -77.399, 43.3117],
    cbd_bbox : Liste von ints, exakt wie `bbox`, aber für den zentralen Geschäftsdistrikt.  
                             Kann genutzt werden um zu große Cluster in der Innenstadt zu reduzieren.
                             Zum deaktivieren null eingeben.
              Beispiel: null

    HUMAN_READABLE : (optional) bool, legt fest ob die erstellte demand_data.json Datei Einrückungen beinhaltet.
                                      Strukturiert für Lesbarkeit (true) oder stattdessen für geringere Dateigröße (false).
              Standard: false
    MAX_WORKERS : (optional) int, Legt die Anzahl an Worker für paralleles berechnen fest.
              Standard: Keine (komplette Anzahl der CPU Threads)
    MAXPOPSIZE : int, Maximalgröße eines Pops.  
                      Pops größer als dieser Wert werden entsprechend in mehrere Pops geteilt.
              Beispiel: 200
    CALCULATE_ROUTES : bool, Legt fest ob Pendlerrouten kalkuliert werden sollen.
                             Für erstes Testen von Begrenzungen und Anhäufungen wird empfohlen, diese Einstellung auf false zu setzen.
                             HINWEIS: Das Berechnen der Routen kann viel Zeit in Anspruch nehmen! Kleine Städte benötigen 15-30 Minuten 
                                   bei 16 CPU Kernen, also ~1-2 Stunden bei CPUs mit 4 Kernen!
                            Beispiel: true
    SMALL_THRESHOLD : int, Maximalgröße der Pops für agglomeratives Clustering.
                           Kleine Pops werden mit Pops in der Nähe zusammengefügt, wenn sie an der gleichen Stelle arbeiten.
                     Beispiel: 100
    DISTANCE_THRESHOLD_NONCBD : float, Distanzschwelle in Grad zur Berücksichtigung von Clustern.
                                       Wird außerhalb der CBD genutzt, oder überall wenn keine CBD
                                       angegeben wurde.
                                       Beachte, dass Nachfragepunkte unter diesem Wert geteilt werden, 
                                       nutze diese Einstellung also nicht als Parameter für die "kleinste Teilung".
                                   Beispiel: 0.1
    DISTANCE_THRESHOLD_CBD : float, wie `DISTANCE_THRESHOLD_NONCBD` aber für den in `cbd_bbox` angegebenen Bereich.
                            Beispiel: 0.05
    DEMAND_FACTOR: float, multipliziert alle LODES Popgrößen um diesen Faktor.
                          Dieser Parameter wird nur angegeben um Städt mit geringer Bevölkerung zu realisieren.
                          Generell wird empfohlen, den Wert bei 1 zu belassen.
                     Beispiel: 2
    
    point_locs_to_move : Liste an Listen von floats, Koordinaten als [lon, lat] von Nachfragepunkten die du aus unterschiedlichen
                                                 Gründen verschieben möchtest (im Wasser, Überschneidung, etc.).  
                                                 Muss exakt der Reihenfolge in `moved_point_locs` entsprechen.
                                                 Nichtbenutzung durch [].
                         Beispiel: [[-77.69260, 43.29925], [-77.69280, 43.28780], [-77.74163, 43.30533], 
                                   [-77.76616, 43.29830], [-77.75377, 43.29501], [-77.73190, 43.29221], 
                                   [-77.71047, 43.28571], [-77.53833, 43.22158]]
    moved_point_locs : Liste an Listen von floats, Koordinaten als [lon, lat] wohin du die Nachfragepunkte 
                                               verschieben möchtest.
                                               Muss exakt der Reihenfolge in `point_locs_to_move` entsprechen.
                         Beispiel: [[-77.69253, 43.29669], [-77.69224, 43.28529], [-77.73431, 43.30351], 
                                   [-77.76969, 43.29365], [-77.75209, 43.29262], [-77.72819, 43.29165], 
                                   [-77.71078, 43.28141], [-77.54152, 43.22132]]
    
    airport_daily_passengers : (optional) Liste von ints, Anzahl der täglichen Passagiere am Flughafen der Stadt.
                            Beispiel: [7000] 
    airport_loc : Liste an Listen von floats, Koordinaten als [lon, lat] von den Flughäfen der Stadt.
                            Beispiel: [[-77.67166, 43.12919]]
    airport_required_locs : Liste von Listen an Listen von floats, Koordinaten als [lon, lat] wo die Flughafenpassagiere 
                                                    wohnen sollen.  Ein Pop wird an jeder Nachfrageblase platziert, 
                                                    die der Koordinate am nächsten ist.
                                                    Wenn du das nicht entscheiden möchtest benutze [] und der Code 
                                                    wird das automatisch berechnen.
                            Beispiel: [[[-77.61298,  43.15729], [-77.60688,  43.15614], [-77.58936,  43.1547 ],
                                       [-77.59342,  43.15564], [-77.6741 ,  43.21029], [-77.61647,  43.10564],
                                       [-77.61391,  43.08771], [-77.55086,  43.11299], [-77.57981,  43.19774],
                                       [-77.4567 ,  43.2146 ], [-77.44227,  43.21617], [-77.68496,  43.18599],
                                       [-77.64286,  43.0601 ], [-77.65179,  43.05802], [-77.44922,  43.01093],
                                       [-77.51514,  43.09333]]]
    air_pop_size_req : Liste von ints, Größe der in `airport_required_locs` festgelegten Pops.  
                            Beachte, dass jeder Pop in mehrere Pops aufgeteilt wird, wenn er den Wert in
                            `MAXPOPSIZE` überschreitet.
                     Beispiel: [200]
    air_pop_size_remain : Liste von ints, Größe der Flughafenpops, die automatisch vom Code zugewiesen werden.
                            Beachte, dass jeder Pop in mehrere Pops aufgeteilt wird, wenn er den Wert in
                            `MAXPOPSIZE` überschreitet.
                     Beispiel: [150]
    
    universities : Liste von strings, 2-4 Identifikationsbuchstaben für jede enthaltene Universität.
                            Alle weiteren universitätsbezogenen Parameter müssen sich exakt an 
                            dieser Reiehenfolge orientieren.
                     Beispiel: ["UR", "RIT", "SJF", "NU", "RWU"],
    univ_loc : Liste an Listen von floats, Koordinaten für die Nachfrageblase jeder Universität.
                     Beispiel: [[-77.62668, 43.12989], [-77.67629, 43.08389], [-77.51239, 43.11575], 
                               [-77.51873, 43.10218], [-77.79857, 43.12568]]
    univ_merge_within : Liste von ints, Distanz in Meter um nahe Nachfragepunkte mit den neuen Universitätspunkten 
                            zu kombinieren.
                     Beispiel: [0, 350, 300, 0, 0]
    students : Liste von ints, Anzahl der Studierenden an jedem Campus.
                     Beispiel: [11946, 17166, 4000, 2500, 1500]
    perc_oncampus : Liste von floats, prozentueller Anteil der Studierenden, die in Wohnheimen auf dem Campus leben, für jede Uni.
                     Beispiel: [0.45, 0.4, 0.33, 0.5, 0.6]
    univ_pop_size : Liste von ints, größe des Pops für jede Universität.
                     Beispiel: [75, 75, 75, 75, 75]
    univ_perc_travel : Liste an Listen von floats, Anteil der Studierenden die [auf dem Campus, außerhalb des Campus] wohnen und 
                            täglich reisen.   
                     Standard: [0.3, 0.5]

    entertainment : Liste von strings, kurze IDs für jeden Entertainmentort.
    ent_loc : Liste an Listen von floats, Koordinaten als [lon, lat] für jeden Entertainmentort. 
    ent_req_residences : Liste von Listen an Listen von floats, wie `airport_required_locs` aber 
                            für Entertainmentorte.
    ent_size : Liste von ints, Anzahl täglicher Besucher für jeden Entertainmentort.
    ent_pop_size : Liste von ints, Größe des Pops für jeden Entertainmentort.
```

Wenn du damit fertig bist, führe den Befehl aus:
```bash
./<DEINE_BINÄR_DATEI>.bin <DEINE_STADT>.json
```

:::important
Möglicherweise musst du einen `MAX_WORKERS` Parameter in deriner Konfiguration angeben, damit das Programm nicht zu viele Ressourcen benötigt. Wenn das Script bei dir abstürzt, setze `MAX_WORKERS` auf eine niedrigere Zahl. Je höher die Zahl, desto schneller läuft das Script, benötigt aber auch mehr Ressourcen.
:::
:::note
Je nach Ausstattung deines Computers, der Kartengröße und dem Wert in `MAX_WORKERS` kann die Berechnung eine Stunde oder mehrere Tage dauern.
:::

Der Prozess generiert eine `demand_data.json` in `demand_data/<DEINE_STADT>/`. Das ist die letzte Datei, die wir zum Erstellen deiner Karte benötigen.
</TabItem>

<TabItem value="macos" label="MacOS">

Öffne https://github.com/rslurry/subwaybuilder-US-demand-data/releases und lade den neuesten Release entsprechend deines Betriebssystems herunter. Erstelle ein temporäres Arbeitsverzeichnis für unsere Dateien und speichere den Release darin. Führe den folgenden Befehl aus(ersetze `<DEINE_BINÄR_DATEI>` mit dem Namen deiner Binärdatei, wo nötig):
```bash
chmod +x <DEINE_BINÄR_DATEI>.bin
```

Jetzt ist es Zeit, unsere Konfiguration zu erstellen. Erstelle eine Datei namens `<DEINE_STADT>.json`, wobei DEINE_STADT den Namen deiner Stadt meint (der Dateiname ist egal, aber das wird es später einfacher machen). Manche Parameter sind optional, einschließlich Flughafenbezogener Orte und Bevölkerungszahlen, Parameter für Universitäten und alle entertainmentbasierten Parameter.

In diese Datei fügst du folgende Parameter ein:
```json
    city : string, deine Stadt.  
              Beispiel: "Rochester"
    airport : Liste von strings, IATA Codes für lokale Flughäfen
                               Beachte: Der zuerst aufgeführte Flughafen wird hier benutzt um die Stadt eindeutig zuzuweisen.
              Beispiel: ["ROC"]
    states : string oder Liste von strings, zwei-Buchstaben Code für den Bundesstaat deiner Karte.
              Beispiel: "ny"
              Beispiel: ["md", "dc", "va"]
    year : int, das Jahr welches du für die LODES Daten benutzen möchtest. Zum Zeitpunkt des Schreibens muss es zwischen 2002-2023 liegen.  
              Beispiel: 2022
    bbox : Liste von ints, die [min_lon, min_lat, max_lon, max_lat] Begrenzungen für deine Stadt.  
              Beispiel: [-77.8216, 43.0089, -77.399, 43.3117],
    cbd_bbox : Liste von ints, exakt wie `bbox`, aber für den zentralen Geschäftsdistrikt.  
                             Kann genutzt werden um zu große Cluster in der Innenstadt zu reduzieren.
                             Zum deaktivieren null eingeben.
              Beispiel: null

    HUMAN_READABLE : (optional) bool, legt fest ob die erstellte demand_data.json Datei Einrückungen beinhaltet.
                                      Strukturiert für Lesbarkeit (true) oder stattdessen für geringere Dateigröße (false).
              Standard: false
    MAX_WORKERS : (optional) int, Legt die Anzahl an Worker für paralleles berechnen fest.
              Standard: Keine (komplette Anzahl der CPU Threads)
    MAXPOPSIZE : int, Maximalgröße eines Pops.  
                      Pops größer als dieser Wert werden entsprechend in mehrere Pops geteilt.
              Beispiel: 200
    CALCULATE_ROUTES : bool, Legt fest ob Pendlerrouten kalkuliert werden sollen.
                             Für erstes Testen von Begrenzungen und Anhäufungen wird empfohlen, diese Einstellung auf false zu setzen.
                             HINWEIS: Das Berechnen der Routen kann viel Zeit in Anspruch nehmen! Kleine Städte benötigen 15-30 Minuten 
                                   bei 16 CPU Kernen, also ~1-2 Stunden bei CPUs mit 4 Kernen!
                            Beispiel: true
    SMALL_THRESHOLD : int, Maximalgröße der Pops für agglomeratives Clustering.
                           Kleine Pops werden mit Pops in der Nähe zusammengefügt, wenn sie an der gleichen Stelle arbeiten.
                     Beispiel: 100
    DISTANCE_THRESHOLD_NONCBD : float, Distanzschwelle in Grad zur Berücksichtigung von Clustern.
                                       Wird außerhalb der CBD genutzt, oder überall wenn keine CBD
                                       angegeben wurde.
                                       Beachte, dass Nachfragepunkte unter diesem Wert geteilt werden, 
                                       nutze diese Einstellung also nicht als Parameter für die "kleinste Teilung".
                                   Beispiel: 0.1
    DISTANCE_THRESHOLD_CBD : float, wie `DISTANCE_THRESHOLD_NONCBD` aber für den in `cbd_bbox` angegebenen Bereich.
                            Beispiel: 0.05
    DEMAND_FACTOR: float, multipliziert alle LODES Popgrößen um diesen Faktor.
                          Dieser Parameter wird nur angegeben um Städt mit geringer Bevölkerung zu realisieren.
                          Generell wird empfohlen, den Wert bei 1 zu belassen.
                     Beispiel: 2
    
    point_locs_to_move : Liste an Listen von floats, Koordinaten als [lon, lat] von Nachfragepunkten die du aus unterschiedlichen
                                                 Gründen verschieben möchtest (im Wasser, Überschneidung, etc.).  
                                                 Muss exakt der Reihenfolge in `moved_point_locs` entsprechen.
                                                 Nichtbenutzung durch [].
                         Beispiel: [[-77.69260, 43.29925], [-77.69280, 43.28780], [-77.74163, 43.30533], 
                                   [-77.76616, 43.29830], [-77.75377, 43.29501], [-77.73190, 43.29221], 
                                   [-77.71047, 43.28571], [-77.53833, 43.22158]]
    moved_point_locs : Liste an Listen von floats, Koordinaten als [lon, lat] wohin du die Nachfragepunkte 
                                               verschieben möchtest.
                                               Muss exakt der Reihenfolge in `point_locs_to_move` entsprechen.
                         Beispiel: [[-77.69253, 43.29669], [-77.69224, 43.28529], [-77.73431, 43.30351], 
                                   [-77.76969, 43.29365], [-77.75209, 43.29262], [-77.72819, 43.29165], 
                                   [-77.71078, 43.28141], [-77.54152, 43.22132]]
    
    airport_daily_passengers : (optional) Liste von ints, Anzahl der täglichen Passagiere am Flughafen der Stadt.
                            Beispiel: [7000] 
    airport_loc : Liste an Listen von floats, Koordinaten als [lon, lat] von den Flughäfen der Stadt.
                            Beispiel: [[-77.67166, 43.12919]]
    airport_required_locs : Liste von Listen an Listen von floats, Koordinaten als [lon, lat] wo die Flughafenpassagiere 
                                                    wohnen sollen.  Ein Pop wird an jeder Nachfrageblase platziert, 
                                                    die der Koordinate am nächsten ist.
                                                    Wenn du das nicht entscheiden möchtest benutze [] und der Code 
                                                    wird das automatisch berechnen.
                            Beispiel: [[[-77.61298,  43.15729], [-77.60688,  43.15614], [-77.58936,  43.1547 ],
                                       [-77.59342,  43.15564], [-77.6741 ,  43.21029], [-77.61647,  43.10564],
                                       [-77.61391,  43.08771], [-77.55086,  43.11299], [-77.57981,  43.19774],
                                       [-77.4567 ,  43.2146 ], [-77.44227,  43.21617], [-77.68496,  43.18599],
                                       [-77.64286,  43.0601 ], [-77.65179,  43.05802], [-77.44922,  43.01093],
                                       [-77.51514,  43.09333]]]
    air_pop_size_req : Liste von ints, Größe der in `airport_required_locs` festgelegten Pops.  
                            Beachte, dass jeder Pop in mehrere Pops aufgeteilt wird, wenn er den Wert in
                            `MAXPOPSIZE` überschreitet.
                     Beispiel: [200]
    air_pop_size_remain : Liste von ints, Größe der Flughafenpops, die automatisch vom Code zugewiesen werden.
                            Beachte, dass jeder Pop in mehrere Pops aufgeteilt wird, wenn er den Wert in
                            `MAXPOPSIZE` überschreitet.
                     Beispiel: [150]
    
    universities : Liste von strings, 2-4 Identifikationsbuchstaben für jede enthaltene Universität.
                            Alle weiteren universitätsbezogenen Parameter müssen sich exakt an 
                            dieser Reiehenfolge orientieren.
                     Beispiel: ["UR", "RIT", "SJF", "NU", "RWU"],
    univ_loc : Liste an Listen von floats, Koordinaten für die Nachfrageblase jeder Universität.
                     Beispiel: [[-77.62668, 43.12989], [-77.67629, 43.08389], [-77.51239, 43.11575], 
                               [-77.51873, 43.10218], [-77.79857, 43.12568]]
    univ_merge_within : Liste von ints, Distanz in Meter um nahe Nachfragepunkte mit den neuen Universitätspunkten 
                            zu kombinieren.
                     Beispiel: [0, 350, 300, 0, 0]
    students : Liste von ints, Anzahl der Studierenden an jedem Campus.
                     Beispiel: [11946, 17166, 4000, 2500, 1500]
    perc_oncampus : Liste von floats, prozentueller Anteil der Studierenden, die in Wohnheimen auf dem Campus leben, für jede Uni.
                     Beispiel: [0.45, 0.4, 0.33, 0.5, 0.6]
    univ_pop_size : Liste von ints, größe des Pops für jede Universität.
                     Beispiel: [75, 75, 75, 75, 75]
    univ_perc_travel : Liste an Listen von floats, Anteil der Studierenden die [auf dem Campus, außerhalb des Campus] wohnen und 
                            täglich reisen.   
                     Standard: [0.3, 0.5]

    entertainment : Liste von strings, kurze IDs für jeden Entertainmentort.
    ent_loc : Liste an Listen von floats, Koordinaten als [lon, lat] für jeden Entertainmentort. 
    ent_req_residences : Liste von Listen an Listen von floats, wie `airport_required_locs` aber 
                            für Entertainmentorte.
    ent_size : Liste von ints, Anzahl täglicher Besucher für jeden Entertainmentort.
    ent_pop_size : Liste von ints, Größe des Pops für jeden Entertainmentort.
```

Wenn du damit fertig bist, führe den Befehl aus:
```bash
./<DEINE_BINÄR_DATEI>.bin <DEINE_STADT>.json
```

:::important
Möglicherweise musst du einen `MAX_WORKERS` Parameter in deriner Konfiguration angeben, damit das Programm nicht zu viele Ressourcen benötigt. Wenn das Script bei dir abstürzt, setze `MAX_WORKERS` auf eine niedrigere Zahl. Je höher die Zahl, desto schneller läuft das Script, benötigt aber auch mehr Ressourcen.
:::
:::note
Je nach Ausstattung deines Computers, der Kartengröße und dem Wert in `MAX_WORKERS` kann die Berechnung eine Stunde oder mehrere Tage dauern.
:::

Der Prozess generiert eine `demand_data.json` in `demand_data/<DEINE_STADT>/`. Das ist die letzte Datei, die wir zum Erstellen deiner Karte benötigen.
</TabItem>

<TabItem value="linux" label="Linux">

Öffne https://github.com/rslurry/subwaybuilder-US-demand-data/releases und lade den neuesten Release entsprechend deines Betriebssystems herunter. Erstelle ein temporäres Arbeitsverzeichnis für unsere Dateien und speichere den Release darin. Führe den folgenden Befehl aus(ersetze `<DEINE_BINÄR_DATEI>` mit dem Namen deiner Binärdatei, wo nötig):
```bash
chmod +x <DEINE_BINÄR_DATEI>.bin
```

From here, it's time to set up our demand generator configuration. Create a file called `<YOUR_CITY>.json`, where your city is the name of your city (the filename does not matter, but this will make it easier later). Some parameters are optional, includung airport required locations and pop sizes, some parameters for universities, and all entertainment-related parameters.

Jetzt ist es Zeit, unsere Konfiguration zu erstellen. Erstelle eine Datei namens `<DEINE_STADT>.json`, wobei DEINE_STADT den Namen deiner Stadt meint (der Dateiname ist egal, aber das wird es später einfacher machen). Manche Parameter sind optional, einschließlich Flughafenbezogener Orte und Bevölkerungszahlen, Parameter für Universitäten und alle entertainmentbasierten Parameter.

In diese Datei fügst du folgende Parameter ein:
```json
    city : string, deine Stadt.  
              Beispiel: "Rochester"
    airport : Liste von strings, IATA Codes für lokale Flughäfen
                               Beachte: Der zuerst aufgeführte Flughafen wird hier benutzt um die Stadt eindeutig zuzuweisen.
              Beispiel: ["ROC"]
    states : string oder Liste von strings, zwei-Buchstaben Code für den Bundesstaat deiner Karte.
              Beispiel: "ny"
              Beispiel: ["md", "dc", "va"]
    year : int, das Jahr welches du für die LODES Daten benutzen möchtest. Zum Zeitpunkt des Schreibens muss es zwischen 2002-2023 liegen.  
              Beispiel: 2022
    bbox : Liste von ints, die [min_lon, min_lat, max_lon, max_lat] Begrenzungen für deine Stadt.  
              Beispiel: [-77.8216, 43.0089, -77.399, 43.3117],
    cbd_bbox : Liste von ints, exakt wie `bbox`, aber für den zentralen Geschäftsdistrikt.  
                             Kann genutzt werden um zu große Cluster in der Innenstadt zu reduzieren.
                             Zum deaktivieren null eingeben.
              Beispiel: null

    HUMAN_READABLE : (optional) bool, legt fest ob die erstellte demand_data.json Datei Einrückungen beinhaltet.
                                      Strukturiert für Lesbarkeit (true) oder stattdessen für geringere Dateigröße (false).
              Standard: false
    MAX_WORKERS : (optional) int, Legt die Anzahl an Worker für paralleles berechnen fest.
              Standard: Keine (komplette Anzahl der CPU Threads)
    MAXPOPSIZE : int, Maximalgröße eines Pops.  
                      Pops größer als dieser Wert werden entsprechend in mehrere Pops geteilt.
              Beispiel: 200
    CALCULATE_ROUTES : bool, Legt fest ob Pendlerrouten kalkuliert werden sollen.
                             Für erstes Testen von Begrenzungen und Anhäufungen wird empfohlen, diese Einstellung auf false zu setzen.
                             HINWEIS: Das Berechnen der Routen kann viel Zeit in Anspruch nehmen! Kleine Städte benötigen 15-30 Minuten 
                                   bei 16 CPU Kernen, also ~1-2 Stunden bei CPUs mit 4 Kernen!
                            Beispiel: true
    SMALL_THRESHOLD : int, Maximalgröße der Pops für agglomeratives Clustering.
                           Kleine Pops werden mit Pops in der Nähe zusammengefügt, wenn sie an der gleichen Stelle arbeiten.
                     Beispiel: 100
    DISTANCE_THRESHOLD_NONCBD : float, Distanzschwelle in Grad zur Berücksichtigung von Clustern.
                                       Wird außerhalb der CBD genutzt, oder überall wenn keine CBD
                                       angegeben wurde.
                                       Beachte, dass Nachfragepunkte unter diesem Wert geteilt werden, 
                                       nutze diese Einstellung also nicht als Parameter für die "kleinste Teilung".
                                   Beispiel: 0.1
    DISTANCE_THRESHOLD_CBD : float, wie `DISTANCE_THRESHOLD_NONCBD` aber für den in `cbd_bbox` angegebenen Bereich.
                            Beispiel: 0.05
    DEMAND_FACTOR: float, multipliziert alle LODES Popgrößen um diesen Faktor.
                          Dieser Parameter wird nur angegeben um Städt mit geringer Bevölkerung zu realisieren.
                          Generell wird empfohlen, den Wert bei 1 zu belassen.
                     Beispiel: 2
    
    point_locs_to_move : Liste an Listen von floats, Koordinaten als [lon, lat] von Nachfragepunkten die du aus unterschiedlichen
                                                 Gründen verschieben möchtest (im Wasser, Überschneidung, etc.).  
                                                 Muss exakt der Reihenfolge in `moved_point_locs` entsprechen.
                                                 Nichtbenutzung durch [].
                         Beispiel: [[-77.69260, 43.29925], [-77.69280, 43.28780], [-77.74163, 43.30533], 
                                   [-77.76616, 43.29830], [-77.75377, 43.29501], [-77.73190, 43.29221], 
                                   [-77.71047, 43.28571], [-77.53833, 43.22158]]
    moved_point_locs : Liste an Listen von floats, Koordinaten als [lon, lat] wohin du die Nachfragepunkte 
                                               verschieben möchtest.
                                               Muss exakt der Reihenfolge in `point_locs_to_move` entsprechen.
                         Beispiel: [[-77.69253, 43.29669], [-77.69224, 43.28529], [-77.73431, 43.30351], 
                                   [-77.76969, 43.29365], [-77.75209, 43.29262], [-77.72819, 43.29165], 
                                   [-77.71078, 43.28141], [-77.54152, 43.22132]]
    
    airport_daily_passengers : (optional) Liste von ints, Anzahl der täglichen Passagiere am Flughafen der Stadt.
                            Beispiel: [7000] 
    airport_loc : Liste an Listen von floats, Koordinaten als [lon, lat] von den Flughäfen der Stadt.
                            Beispiel: [[-77.67166, 43.12919]]
    airport_required_locs : Liste von Listen an Listen von floats, Koordinaten als [lon, lat] wo die Flughafenpassagiere 
                                                    wohnen sollen.  Ein Pop wird an jeder Nachfrageblase platziert, 
                                                    die der Koordinate am nächsten ist.
                                                    Wenn du das nicht entscheiden möchtest benutze [] und der Code 
                                                    wird das automatisch berechnen.
                            Beispiel: [[[-77.61298,  43.15729], [-77.60688,  43.15614], [-77.58936,  43.1547 ],
                                       [-77.59342,  43.15564], [-77.6741 ,  43.21029], [-77.61647,  43.10564],
                                       [-77.61391,  43.08771], [-77.55086,  43.11299], [-77.57981,  43.19774],
                                       [-77.4567 ,  43.2146 ], [-77.44227,  43.21617], [-77.68496,  43.18599],
                                       [-77.64286,  43.0601 ], [-77.65179,  43.05802], [-77.44922,  43.01093],
                                       [-77.51514,  43.09333]]]
    air_pop_size_req : Liste von ints, Größe der in `airport_required_locs` festgelegten Pops.  
                            Beachte, dass jeder Pop in mehrere Pops aufgeteilt wird, wenn er den Wert in
                            `MAXPOPSIZE` überschreitet.
                     Beispiel: [200]
    air_pop_size_remain : Liste von ints, Größe der Flughafenpops, die automatisch vom Code zugewiesen werden.
                            Beachte, dass jeder Pop in mehrere Pops aufgeteilt wird, wenn er den Wert in
                            `MAXPOPSIZE` überschreitet.
                     Beispiel: [150]
    
    universities : Liste von strings, 2-4 Identifikationsbuchstaben für jede enthaltene Universität.
                            Alle weiteren universitätsbezogenen Parameter müssen sich exakt an 
                            dieser Reiehenfolge orientieren.
                     Beispiel: ["UR", "RIT", "SJF", "NU", "RWU"],
    univ_loc : Liste an Listen von floats, Koordinaten für die Nachfrageblase jeder Universität.
                     Beispiel: [[-77.62668, 43.12989], [-77.67629, 43.08389], [-77.51239, 43.11575], 
                               [-77.51873, 43.10218], [-77.79857, 43.12568]]
    univ_merge_within : Liste von ints, Distanz in Meter um nahe Nachfragepunkte mit den neuen Universitätspunkten 
                            zu kombinieren.
                     Beispiel: [0, 350, 300, 0, 0]
    students : Liste von ints, Anzahl der Studierenden an jedem Campus.
                     Beispiel: [11946, 17166, 4000, 2500, 1500]
    perc_oncampus : Liste von floats, prozentueller Anteil der Studierenden, die in Wohnheimen auf dem Campus leben, für jede Uni.
                     Beispiel: [0.45, 0.4, 0.33, 0.5, 0.6]
    univ_pop_size : Liste von ints, größe des Pops für jede Universität.
                     Beispiel: [75, 75, 75, 75, 75]
    univ_perc_travel : Liste an Listen von floats, Anteil der Studierenden die [auf dem Campus, außerhalb des Campus] wohnen und 
                            täglich reisen.   
                     Standard: [0.3, 0.5]

    entertainment : Liste von strings, kurze IDs für jeden Entertainmentort.
    ent_loc : Liste an Listen von floats, Koordinaten als [lon, lat] für jeden Entertainmentort. 
    ent_req_residences : Liste von Listen an Listen von floats, wie `airport_required_locs` aber 
                            für Entertainmentorte.
    ent_size : Liste von ints, Anzahl täglicher Besucher für jeden Entertainmentort.
    ent_pop_size : Liste von ints, Größe des Pops für jeden Entertainmentort.
```

Wenn du damit fertig bist, führe den Befehl aus:
```bash
./<DEINE_BINÄR_DATEI>.bin <DEINE_STADT>.json
```

:::important
Möglicherweise musst du einen `MAX_WORKERS` Parameter in deriner Konfiguration angeben, damit das Programm nicht zu viele Ressourcen benötigt. Wenn das Script bei dir abstürzt, setze `MAX_WORKERS` auf eine niedrigere Zahl. Je höher die Zahl, desto schneller läuft das Script, benötigt aber auch mehr Ressourcen.
:::
:::note
Je nach Ausstattung deines Computers, der Kartengröße und dem Wert in `MAX_WORKERS` kann die Berechnung eine Stunde oder mehrere Tage dauern.
:::

Der Prozess generiert eine `demand_data.json` in `demand_data/<DEINE_STADT>/`. Das ist die letzte Datei, die wir zum Erstellen deiner Karte benötigen.
</TabItem>

</Tabs>

## Schritt 4 - Die Config-Datei erstellen {#creating-the-config-file}

Um mit diesem Schritt fortzufahren benötigen wir insgesamt fünf Dateien:
 - `demand_data.json` (generiert mit dem Demand Data Generator)
 - `buildings_index.json` (generiert mit dem Map Patcher)
 - `roads.geojson` (generiert mit dem Map Patcher)
 - `runways_taxiways.geojson` (generiert mit dem Map Patcher)
 - `XXX.pmtiles` (generiert mit dem Map Patcher; `XXX` ist dein Städtecode)

Erstelle eine neue Datei in deinem Arbeitsverzeichnis und nenne sie `config.json`. Diese Datei wird unsere Einstellungen für den Map Manager beinhalten. Füge diese Vorlage darin ein:
```json
{
  "name": "Wyoming",
  "code": "WYO",
  "description": "it's wyomin' time",
  "population": 240000,
  "initialViewState": {
    "zoom": 12,
    "latitude": 42.731833,
    "longitude": -107.300720,
    "bearing": 0
  },
  "creator": "muffintime",
  "version": "1.0.0"
}
```

:::tip
Weitere optionale Konfigurationsmöglichkeiten findest du unter [optionale Funktionen](/modding-docs/creating-maps/custom-map-optional-features).
:::
Bearbeite die Vorlage, wie sie für dich passt. Für `creator` und `version` kannst du beliebige Werte eintragen.

:::warning
Die Felder `name`, `code`, `description`, `population` und `initialViewState` sollten alle **exakt** den Werten entsprechen, die du im Map Patcher benutzt hast. Wenn du sie nicht genau übernimmst, kann das für Spieler nachher zu Problemen führen.
:::


## Schritt 5 - Die Karte verpacken {#packaging-the-map}

<Tabs>
<TabItem value="windows" label="Windows" default>

Jetzt sollten wir insgesamt sechs Dateien haben (die fünf oben genannten und unsere gerade erstellte `config.json`). Diese werden für die Distribution unserer Karte an andere Spieler in einer ZIP verpackt.


Öffne ein Terminal und navigiere in das Arbeitsverzeichnis mit allen sechs Dateien. Installiere das `zip` Package, falls noch nicht geschehen. Dafür führst du diesen Befehl aus:
```bash
sudo apt install zip
```

Damit können wir ZIP-Archive über das Terminal erzeugen. Führe folgenden Befehl aus(ersetze `MAP_NAME.zip` und `XXX.pmtiles` entsprechend):
```bash
zip MAP_NAME.zip demand_data.json buildings_index.json roads.geojson runways_taxiways.geojson XXX.pmtiles config.json
```

:::danger Vorsicht
Du kannst die ZIP beliebig manuell erstellen. **Achte darauf, dass sich alle Dateien im Root der ZIP befinden, nicht in einem Unterordner.** Das korrekte Format sieht so aus:
```
- MAP_NAME.zip
--- demand_data.json
--- building_index.json
--- roads.geojson
--- runways_taxiways.geojson
--- config.json
--- XXX.pmtiles
```

und NICHT:
```
- MAP_NAME.zip
// highlight-next-line
--- Unterordner
----- demand_data.json
----- building_index.json
----- roads.geojson
----- runways_taxiways.geojson
----- config.json
----- XXX.pmtiles
```
:::
</TabItem>

<TabItem value="macos" label="MacOS">

Jetzt sollten wir insgesamt sechs Dateien haben (die fünf oben genannten und unsere gerade erstellte `config.json`). Diese werden für die Distribution unserer Karte an andere Spieler in einer ZIP verpackt.


Öffne ein Terminal und navigiere in das Arbeitsverzeichnis mit allen sechs Dateien. Wir können das ZIP-Archiv über das Terminal erstellen. Führe folgenden Befehl aus (ersetze `MAP_NAME.zip` und `XXX.pmtiles` entsprechend):
```bash
zip MAP_NAME.zip demand_data.json buildings_index.json roads.geojson runways_taxiways.geojson XXX.pmtiles config.json
```

:::danger Vorsicht
Du kannst die ZIP beliebig manuell erstellen. **Achte darauf, dass sich alle Dateien im Root der ZIP befinden, nicht in einem Unterordner.** Das korrekte Format sieht so aus:
```
- MAP_NAME.zip
--- demand_data.json
--- building_index.json
--- roads.geojson
--- runways_taxiways.geojson
--- config.json
--- XXX.pmtiles
```

und NICHT:
```
- MAP_NAME.zip
// highlight-next-line
--- Unterordner
----- demand_data.json
----- building_index.json
----- roads.geojson
----- runways_taxiways.geojson
----- config.json
----- XXX.pmtiles
```
:::
</TabItem>

<TabItem value="linux" label="Linux">

Jetzt sollten wir insgesamt sechs Dateien haben (die fünf oben genannten und unsere gerade erstellte `config.json`). Diese werden für die Distribution unserer Karte an andere Spieler in einer ZIP verpackt.


Öffne ein Terminal und navigiere in das Arbeitsverzeichnis mit allen sechs Dateien. Installiere das `zip` Package, falls noch nicht geschehen. Dafür führst du diesen Befehl aus:
```bash
sudo apt install zip
```

Damit können wir ZIP-Archive über das Terminal erzeugen. Führe folgenden Befehl aus(ersetze `MAP_NAME.zip` und `XXX.pmtiles` entsprechend):
```bash
zip MAP_NAME.zip demand_data.json buildings_index.json roads.geojson runways_taxiways.geojson XXX.pmtiles config.json
```

:::danger Vorsicht
Du kannst die ZIP beliebig manuell erstellen. **Achte darauf, dass sich alle Dateien im Root der ZIP befinden, nicht in einem Unterordner.** Das korrekte Format sieht so aus:
```
- MAP_NAME.zip
--- demand_data.json
--- building_index.json
--- roads.geojson
--- runways_taxiways.geojson
--- config.json
--- XXX.pmtiles
```

und NICHT:
```
- MAP_NAME.zip
// highlight-next-line
--- Unterordner
----- demand_data.json
----- building_index.json
----- roads.geojson
----- runways_taxiways.geojson
----- config.json
----- XXX.pmtiles
```
:::
</TabItem>

</Tabs>

## Schritt 6 - Testen und Distribution deiner Karte {#testing-and-distributing-your-map}

Wenn du das ZIP-Archiv hast, ist deine Karte fertig! Jetzt musst du sie nur noch testen und an andere Nutzer verteilen. Importiere deine Karte mit dem Map Manager (folge dafür der [Karten-Installationsanleitung](/wiki/maps/map-installation-guide) falls nötig). Teste deine Karte im Spiel um sicherzustellen, dass sie fehlerfrei geöffnet wird und die Nachfragedaten gut aussehen. Falls nicht, kannst du die Parameter für den Demand Data Generator anpassen und die Daten neu generieren. Stelle sicher, dass du bei der Veröffentlichung deiner Karte die Qualität der Nachfragedaten angibst, beispielsweise sehr gut, gut, OK, akzeptabel oder schlecht.

Um dein ZIP-Archiv zu teilen lädst du es auf einem Datenservice wie Google Drive oder Mediafire hoch. Kopiere den Freigabelink (stelle sicher, dass die Datei öffentlich zugänglich / sichtbar ist.).
:::note
Da GitHub Dateigrößen einschränkt, wird nicht empfohlen die Karte auf GitHub hochzuladen. Du kannst GitHub sicher nutzen, wenn dein ZIP-Archiv unter 100 MB groß ist. Es wird stärkstens davon **abgeraten**, GitHub LFS zu nutzen.
:::

Auf der [Issues-Seite](https://github.com/Subway-Builder-Modded/Subway-Builder-Modded-Docs/issues) des Wikis kannst du ein Ticket mit dem Präfix [New Map] und dem Namen deiner Karte eröffnen. Füge einen Downloadlink für deine Karte sowie **die im Wiki anzuzeigende Einwohnerzahl** hinzu. Zusätzlich kannst du die Karte im #map-sharing Kanal auf dem [Subway Builder Discord](https://discord.gg/jrNQpbytUQ) posten.

Fertig! Wenn du weitere Unterstützung für Fragen oder Problembehandlung mit dem Demand Data Generator oder dem Map Patcher brauchst, kannst du im #mod-support Kanal auf dem Subway Builder Discord nachfragen.
